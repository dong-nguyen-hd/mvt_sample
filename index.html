<!DOCTYPE html>
<html data-theme="light">

<head>
    <meta charset=utf-8 />
    <meta name="viewport" content="initial-scale=1,maximum-scale=1,user-scalable=no" />
    <link rel="icon" href="https://elastic.co/favicon.ico" type="image/x-icon">
    <script src='https://unpkg.com/maplibre-gl@1.15.2/dist/maplibre-gl.js'></script>
    <link href='https://unpkg.com/maplibre-gl@1.15.2/dist/maplibre-gl.css' rel='stylesheet' />
    <link rel="stylesheet" href="https://unpkg.com/@picocss/pico@latest/css/pico.min.css" />
    <style>
        :root {
            --spacing: .25rem;
            --font-size: 14px;
            --form-element-spacing-vertical: .5rem;
            --form-element-spacing-horizontal: .25rem;
        }

        #map {
            position: absolute;
            top: 0;
            right: 0;
            bottom: 0;
            left: 0;
            z-index: 1;
        }

        #form {
            position: fixed;
            top: 10px;
            right: 10px;
            background-color: rgba(255, 255, 255, 0.75);
            z-index: 2;
            padding: 10px;
            /*width: 500px;*/
        }

        #show_data {
            margin-top: var(--form-element-spacing-vertical);
        }

        legend {
            font-size: calc(var(--font-size) * 1.3);
        }
    </style>
</head>

<body>
    <div id="form">
        <legend>Add an Elasticsearch layer</legend>
        <div class="">
            <label for="index">Index</label>
            <input required type="text" id="index" value="location" />

            <label for="geometry_field">Geometry field</label>
            <input required type="text" id="geometry_field" value="coordinate" />

            <label>Layer type</label>
            <div>
                <input type="radio" name="renderMethod" id="grid" value="grid" checked /><label
                    for="grid"><small>Grid</small></label><br />
                <!-- <input type="radio" name="renderMethod" id="hex" value="hex" /><label
                    for="hex"><small>Hexagons</small></label><br /> -->
                <input type="radio" name="renderMethod" id="hits" value="hits" /><label
                    for="hits"><small>Documents</small></label><br />
                <input type="radio" name="renderMethod" id="heat" value="heat" /><label
                    for="heat"><small>Heat</small></label><br />
                <input type="radio" name="renderMethod" id="cluster" value="cluster" /><label
                    for="cluster"><small>Cluster</small></label><br />
            </div>

            <label for="search">Search</label>
            <input required type="text" id="search" value='{ "match": { "address": "Địa chỉ" }}'/>

            <input type="button" id="show_data" value="Show" onclick="showLayer()" />
        </div>
        </fieldset>
    </div>
    <div id="map"></div>
    <script>

        let loaded = false;

        const map = new maplibregl.Map({
            container: 'map',
            center: [106.085, 16.417],
            style: 'https://api.maptiler.com/maps/streets/style.json?key=get_your_own_OpIi9ZULNHzrESv6T2vL',
            zoom: 5
        });

        // Bản đồ nền
        // map.addSource('roadmap', {
        //     type: 'raster',
        //     tiles: ['https://basemap.nationalmap.gov/arcgis/rest/services/USGSTopo/MapServer/tile/{z}/{y}/{x}'],
        //     tileSize: 256,
        //     scheme: 'xyz',
        // });

        // map.addLayer({
        //     id: 'base-layer',
        //     type: 'raster',
        //     source: 'roadmap',
        // });

        map.on('load', function () {
            loaded = true;
        });

        function showLayer() {
            if (!loaded) {
                return;
            }

            // Lấy giá trị từ DOM
            const indexName = document.getElementById('index').value;
            const geometryFieldName = document.getElementById('geometry_field').value;
            const renderMethod = document.querySelector('input[name="renderMethod"]:checked').value;
            const searchQuery = document.getElementById('search').value;

            // Validate
            if (!indexName) {
                alert('Cannot show layer. Please set "Elasticsearch index name"');
                return;
            }
            if (!indexName || !geometryFieldName) {
                alert('Cannot show layer. Please set "Field name of geometry"');
                return;
            }

            // arbitrary value, you can use any string you like
            const sourceName = 'es_mvt';
            const fillStyle = 'layer_fill';
            const outlineStyle = 'layer_line';
            const circleStyle = 'layer_point';
            const heatStyle = 'layer_heat';
            const clustertyle = 'layer_cluster';

            // Elasticsearch vector tile API returns tiles with 3 layers
            // "hits": Contains a feature for each document (hit) matching search criteria.
            // "aggs": Contains a feature for each bucket returned from geotile_grid or geohex_grid aggregation.
            // "meta": Contains a single feature with meta data about the feature properties.
            //         These are useful for calculating dynamic style ranges but not used in this example.

            // 'vector' layer specification requires "source-layer" property. This property identifies the layer to display from the tile.
            const sourceLayer = renderMethod === "grid" || renderMethod === "hex" || renderMethod === "heat" || renderMethod === "cluster" ? "aggs" : "hits"; // not arbitrary value - must be layer name provided from tile

            if (map.getSource(sourceName)) {
                map.removeLayer(outlineStyle);
                map.removeLayer(fillStyle);
                map.removeLayer(circleStyle);
                map.removeLayer(heatStyle);
                map.removeLayer(clustertyle);
                map.removeLayer("cluster-count");
                map.removeLayer("unclustered-point");
                map.removeSource(sourceName);
            }

            map.addSource(sourceName, {
                'type': 'vector',
                'tiles': [
                    `http://localhost/tile?index=${indexName}&geometry=${geometryFieldName}&renderMethod=${renderMethod}&x={x}&y={y}&z={z}&searchQuery=${searchQuery}`
                ],
                'minzoom': 0,
                'maxzoom': 24,
                "cluster": true,
                "clusterMaxZoom": 14, // Max zoom to cluster points on
                "clusterRadius": 50, // Radius of each cluster when clustering points (defaults to 50)
            });

            const fillColor = 'rgb(255,0,0)';
            const fillOpacity = 0.5;
            const strokeColor = 'rgb(255,0,0)';
            const strokeOpacity = 1;
            const strokeWidth = 1;

            if (renderMethod == 'grid') {
                map.addLayer(
                    {
                        'id': outlineStyle,
                        'type': 'line',
                        'source': sourceName,
                        'source-layer': sourceLayer,
                        'paint': {
                            'line-opacity': strokeOpacity,
                            'line-color': strokeColor,
                            'line-width': 1,
                        }
                    }
                );
                map.setFilter(outlineStyle, [
                    'any',
                    ['==', ['geometry-type'], 'Polygon'],
                    ['==', ['geometry-type'], 'MultiPolygon'],
                    ['==', ['geometry-type'], 'LineString'],
                    ['==', ['geometry-type'], 'MultiLineString'],
                ]);
            }

            if (renderMethod == 'hex') {
                map.addLayer(
                    {
                        'id': fillStyle,
                        'type': 'fill',
                        'source': sourceName,
                        'source-layer': sourceLayer,
                        'paint': {
                            'fill-opacity': fillOpacity,
                            'fill-color': fillColor,
                        }
                    }
                );
                map.setFilter(fillStyle, [
                    'any',
                    ['==', ['geometry-type'], 'Polygon'],
                    ['==', ['geometry-type'], 'MultiPolygon'],
                ]);
            }

            if (renderMethod == 'hits') {
                map.addLayer(
                    {
                        'id': circleStyle,
                        'type': 'circle',
                        'source': sourceName,
                        'source-layer': sourceLayer,
                        'paint': {
                            'circle-radius': 4,
                            'circle-color': fillColor,
                            'circle-opacity': fillOpacity,
                            'circle-stroke-color': strokeColor,
                            'circle-stroke-opacity': strokeOpacity,
                            'circle-stroke-width': strokeWidth,
                        }
                    }
                );
                map.setFilter(circleStyle, [
                    'any',
                    ['==', ['geometry-type'], 'Point'],
                    ['==', ['geometry-type'], 'MultiPoint'],
                ]);
            }

            if (renderMethod == 'heat') {
                map.addLayer(
                    {
                        'id': heatStyle,
                        'type': 'heatmap',
                        'source': sourceName,
                        'source-layer': sourceLayer,
                        'maxzoom': 9,
                        'paint': {
                            // Increase the heatmap weight based on frequency and property magnitude
                            'heatmap-weight': [
                                'interpolate',
                                ['linear'],
                                ['get', 'mag'],
                                0,
                                0,
                                6,
                                1
                            ],
                            // Increase the heatmap color weight weight by zoom level
                            // heatmap-intensity is a multiplier on top of heatmap-weight
                            'heatmap-intensity': [
                                'interpolate',
                                ['linear'],
                                ['zoom'],
                                0,
                                1,
                                9,
                                3
                            ],
                            // Color ramp for heatmap.  Domain is 0 (low) to 1 (high).
                            // Begin color ramp at 0-stop with a 0-transparancy color
                            // to create a blur-like effect.
                            'heatmap-color': [
                                'interpolate',
                                ['linear'],
                                ['heatmap-density'],
                                0,
                                'rgba(33,102,172,0)',
                                0.2,
                                'rgb(103,169,207)',
                                0.4,
                                'rgb(209,229,240)',
                                0.6,
                                'rgb(253,219,199)',
                                0.8,
                                'rgb(239,138,98)',
                                1,
                                'rgb(178,24,43)'
                            ],
                            // Adjust the heatmap radius by zoom level
                            'heatmap-radius': [
                                'interpolate',
                                ['linear'],
                                ['zoom'],
                                0,
                                2,
                                9,
                                20
                            ],
                            // Transition from heatmap to circle layer by zoom level
                            'heatmap-opacity': [
                                'interpolate',
                                ['linear'],
                                ['zoom'],
                                7,
                                1,
                                9,
                                0
                            ]
                        }
                    }
                );
                map.setFilter(heatStyle, [
                    'any',
                    ['==', ['geometry-type'], 'Polygon'],
                    ['==', ['geometry-type'], 'MultiPolygon'],
                    ['==', ['geometry-type'], 'LineString'],
                    ['==', ['geometry-type'], 'MultiLineString'],
                ]);
            }

            if (renderMethod == 'cluster') {
                map.addLayer({
                    'id': clustertyle,
                    'type': 'circle',
                    'source': sourceName,
                    'source-layer': sourceLayer,
                    'filter': ['has', 'point_count'],
                    'paint': {
                        // Use step expressions (https://docs.mapbox.com/mapbox-gl-js/style-spec/#expressions-step)
                        // with three steps to implement three types of circles:
                        //   * Blue, 20px circles when point count is less than 100
                        //   * Yellow, 30px circles when point count is between 100 and 750
                        //   * Pink, 40px circles when point count is greater than or equal to 750
                        'circle-color': [
                            'step',
                            ['get', 'point_count'],
                            '#51bbd6',
                            100,
                            '#f1f075',
                            750,
                            '#f28cb1'
                        ],
                        'circle-radius': [
                            'step',
                            ['get', 'point_count'],
                            20,
                            100,
                            30,
                            750,
                            40
                        ]
                    }
                });

                map.addLayer({
                    id: 'cluster-count',
                    type: 'symbol',
                    'source': sourceName,
                    'source-layer': sourceLayer,
                    filter: ['has', 'point_count'],
                    layout: {
                        'text-field': '{point_count_abbreviated}',
                        'text-font': ['DIN Offc Pro Medium', 'Arial Unicode MS Bold'],
                        'text-size': 12
                    }
                });

                map.addLayer({
                    id: 'unclustered-point',
                    type: 'circle',
                    'source': sourceName,
                    'source-layer': sourceLayer,
                    filter: ['!', ['has', 'point_count']],
                    paint: {
                        'circle-color': '#11b4da',
                        'circle-radius': 4,
                        'circle-stroke-width': 1,
                        'circle-stroke-color': '#fff'
                    }
                });
            }
        }

        document.onkeydown = function (evt) {
            var keyCode = evt
                ? evt.which
                    ? evt.which
                    : evt.keyCode
                : event.keyCode;
            if (keyCode == 13) { showLayer(); }
        };
    </script>
</body>

</html>